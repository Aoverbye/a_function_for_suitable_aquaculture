---
title: "eds223_hw4_Aoverbye"
author: "Amanda G. Overbye"
date: last-modified
execute: 
  eval: true
  warning: false
format:
  html:
    code-fold: true
    toc: true
editor_options: 
  chunk_output_type: console
---

# Homework Assignment 4

## Fun with Fish Functions!

#### Prioritizing potential aquaculture

##### by Amanda Overbye

# Creating A Function

"To make your workflow generalizable, you must create a function that has the following characteristics:

**arguments:**

-   minimum and maximum sea surface temperature
-   minimum and maximum depth species name

**outputs:**

-   map of EEZ regions colored by amount of suitable area species
    -   species name should be included in the mapâ€™s title

```{r}
# Load libraries
library(tidyverse)
library(here) 
library(tmap)
library(ggplot2)
library(stars)
library(spDataLarge)
library(dplyr)
library(terra)

```

## Prepare data

```{r, message=FALSE, results='hide', warning=FALSE}
# Load data
# Read in NOAA Sea Surface Temperature files
sst_avg2008 <- read_stars(here("data", "average_annual_sst_2008.tif"))
sst_avg2009 <- read_stars(here("data", "average_annual_sst_2009.tif"))
sst_avg2010 <- read_stars(here("data", "average_annual_sst_2010.tif"))
sst_avg2011 <- read_stars(here("data", "average_annual_sst_2011.tif"))
sst_avg2012 <- read_stars(here("data", "average_annual_sst_2012.tif"))

# Read in Bathymetry files
depth <- read_stars(here("data", "depth.tif"))

# Load wc_regions shape file
wc_regions_clean <- st_read(here("data", "Wc_regions_clean.shp"))
```

#### Stacking Rasters

# **Write about why stacking rasters is useful**

# \*\* Write about why we crop rasters\*\*

```{r}
# Crop all rasters to the extent of the first raster
sst_avg2009 <- st_crop(sst_avg2009, st_bbox(sst_avg2008))
sst_avg2010 <- st_crop(sst_avg2010, st_bbox(sst_avg2008))
sst_avg2011 <- st_crop(sst_avg2011, st_bbox(sst_avg2008))
sst_avg2012 <- st_crop(sst_avg2012, st_bbox(sst_avg2008))
```

```{r}
# Stacking Rasters
sst_avg_stack <- c(sst_avg2008, sst_avg2009, sst_avg2010, sst_avg2011, sst_avg2012)
```

```{r}
# Plot to view
plot(sst_avg_stack)
```

### Preliminary Data Exploration

My first step in this project is getting an overview of the data I am. I do this by looking at the first 5 rows(head) of any shape files and by doing a quick plot of the tif files.

```{r, message=FALSE, results='hide', warning=FALSE}
# View the column names of the wc_regions data
print(colnames(wc_regions_clean))
print(head(wc_regions_clean))
```

```{r}
# Plot bathymetry data
plot(depth)
```

I am only going to show one plot of the surface temperature data because that is all I need right now to get an idea of how it will look.

```{r}
# Plot the temperature data
plot(sst_avg2008)
```

## Processing The data!

## find the mean SST from 2008-2012 (e.g. create single raster of average SST)

## convert average SST from Kelvin to Celsius

## hint: subtract by 273.15

First we want to get the mean over all the years.

```{r}
sst_mean <- st_apply(sst_avg_stack, c("x", "y"), FUN = mean)

# Select a single attribute using dplyr::select
sst_mean <- sst_mean %>% select("average_annual_sst_2008.tif")
```

Then we want to view the plot to ensure we did not destroy the data in the process.

```{r}
# View plot 
plot(sst_mean)
```

Our original temperature data is in Kelvin, but most people don't use Kelvin so we will change it to Celsius by subtracting 273.5.

```{r}
# Transfer to Celsius
celsius_mean_sst <- sst_mean - 273.15
```

#### Cropping Rasters

Next, we need to process the SST and depth data so that they can be combined. In this case the SST and depth data have slightly different resolutions, extents, and positions.

##### Extent

In basic terms, the extent of the raster is the box around the geographic area it covers. It wouldn't be useful if the two maps covered completely separate areas. One of the easiest ways to fix mis-match extents is just to create a bounding box. A bounding box will make it so only the data within a certain geographical region will be used. For this I will take the dataset with the larger extent (depth) and crop it to match the extent of the other dataset(celsius_mean_sst). Normally this would mean the dataset with the smaller extent then becomes the bounding box.

```{r}
# Crop the depth data to the mean_sst_celsius data
cropped_depth <- st_crop(depth, st_bbox(celsius_mean_sst))
```

##### Resolution

**Talk about resolution**

When working with maps resolution is basically how detailed the image is. Making sure the resolution between our maps is the same is important. If we don't pay attention to resolution we can get maps that look weird and are inaccurate. Its like photoshoping a very pixelated image onto a very clear image, it looks weird and we can tell its wrong.

Like before we are going to try a function for this as well.

```{r}
# Function to determine if Resolutions match
check_res_fun <- function(d1, d2) {
  if (identical(st_dimensions(d1), st_dimensions(d2))) {
    return(print("Resolutions match!"))
  } else {
    return(print("Resolutions do not match"))
  }
}
```

```{r}
# Use the function to check the resolutions
check_res_fun(cropped_depth, celsius_mean_sst)
```

I can see that are resolutions do not match, so I must make them match myself.

```{r}
# Resample the depth data to the mean_sst_celsius data using the near method
resampled_depth <- st_warp(cropped_depth, celsius_mean_sst, method = "near")

# Check if the resolutions match now
check_res_fun(resampled_depth, celsius_mean_sst)
```

So now the resolutions match.

```{r}
cropped_depth <- st_crop(resampled_depth, st_bbox(celsius_mean_sst))
```

In the process of matching everything, I made several different variables representing the changes I make particularly to the depth variable. In order to avoid confusion, I am going to re-assign the names.

```{r}
# Re-assign cropped_depth
depth_clean <- cropped_depth
sst_clean <- celsius_mean_sst
```

```{r}
test_stack <- c(depth_clean, sst_clean)
```

#### CRS systems

One of things I have learned is that mismatching CRSs is one of the things that will derail me the most when I am trying to work with geographical data sets. Lots of weird things can happen when coding and I think in projects like these about 90% of those things are caused by CRS troubles. If I were ever caught in the bad place, one of the signs would be mis-matched CRSs.

In order to prevent these troubles, I will write a function that will tell me if data sets have mismatching CRSs

```{r}
# Function to determine if CRSs match
check_crs_fun <- function(d1, d2) {
  if (identical(st_crs(d1), st_crs(d2))) {
    return(print("CRSs match!"))
  } else {
    return(print("CRSs do not match"))
  }
}
```

Then we can check our data sets:

```{r, message=FALSE, results='hide', warning=FALSE}
check_crs_fun(depth_clean, sst_clean)
check_crs_fun(depth_clean, wc_regions_clean)
check_crs_fun(wc_regions_clean, sst_clean)
```

Here I can see that two of my CRSs match.

Our next step will be to change the CRSs so they are consistent. We will do this by creating a function that will change the CRS of the first inputted dataset to match the crs of the second inputted dataset. I am going to change the CRSs of the `depth` and `wc_regions_clean` datasets to match the `sst_avg` datasets.

```{r}
change_crs_fun <- function(df1, df2) {
  if (identical(st_crs(df1), st_crs(df2))) {
    print("no change")
    return(df1)
  } else {
    df1 <- st_transform(df1, st_crs(df2))
    print("changed first dataset's CRS to match the second dataset's CRS")
    return(df1)
  }
}
```

```{r}
# Change the CRSs to match and store in new varibles
depth_clean <- change_crs_fun(depth_clean, sst_clean)
wc_regions_clean <- change_crs_fun(wc_regions_clean, sst_clean)
```

```{r}
# Check if the CRSs match now 
check_crs_fun(depth_clean, sst_clean)
check_crs_fun(wc_regions_clean, sst_clean)
```

All of our CRSs should be the same now. By check st_crs(sst_avg2008), I can see that the CRS the sst_avg2008 uses is EPSG 9122. So I will now create a warning message that will tell me if there CRS is not 9122.

```{r}
# Create crs warning function
crs_warning <- function(df) {
  # Check if the CRS is different from EPSG:9122
  if (st_crs(df) != st_crs(sst_avg2008)) {
    warning("Warning: The CRS of the dataset is not EPSG:9122!")
  } else {
    message("The CRS is EPSG:9122.")
  }
}
```

Because we stacked the rasters, we want to ensure that the CRSs will still match what we had before, so we are going to run our CRS matching function again.

```{r}
crs_warning(sst_avg_stack)
```

## Find suitable locations

```{r}
# Reclassify SST (keep logical 1/0 format)
suitable_sst <- (celsius_mean_sst >= 8 & celsius_mean_sst <= 18)

# Convert the logical values (TRUE/FALSE) to integers (1/0) and preserve the stars format
suitable_sst <- st_apply(suitable_sst, c("x", "y"), function(x) as.integer(x))

```

```{r}
plot(suitable_sst)
```

```{r}
# Reclassify Depth (keep logical 1/0 format)
suitable_depth <- (depth_clean >= -24 & depth_clean <= 0)

# Convert logical values (TRUE/FALSE) to integers (1/0)
suitable_depth <- st_apply(suitable_depth, c("x", "y"), function(x) as.integer(x))

```

```{r}
plot(suitable_depth)
```

```{r}
suitable_locations <- suitable_sst * suitable_depth
```

# Creating A Central California Area For Funsies

```{r, message=FALSE, results='hide', warning=FALSE}
head(wc_regions_clean)

central_california <- wc_regions_clean %>% 
  filter(rgn == "Central California")  # Filter by the region name

# Step 2: Get the bounding box of Central California
central_california_bbox <- st_bbox(central_california)

# Print the bounding box
print(central_california_bbox)
```

## Creating the main function aka the

# MEGA-FUNCTION


# create a function that will map suitable areas

First I am just going to make a function that will map an area based on temperature and depth that will include the name of the species in the title.


```{r}
# Create function
area_map_fun <- function(min_temp, max_temp, min_depth, max_depth, species_name) {
 
# Reclassify Depth (keep logical 1/0 format)
depth_range <- (depth_clean >= min_depth & depth_clean <= max_depth)

# Convert logical values (TRUE/FALSE) to integers (1/0)
depth_range <- st_apply(depth_range, c("x", "y"), function(x) as.integer(x))

depth_range[is.na(depth_range)] <- 0

## Reclassify SST (keep logical 1/0 format)
sst_range <- (celsius_mean_sst >= min_temp & celsius_mean_sst <= max_temp)

# Convert the logical values (TRUE/FALSE) to integers (1/0) and preserve the stars format
sst_range <- st_apply(sst_range, c("x", "y"), function(x) as.integer(x))

sst_range[is.na(sst_range)] <- 0

combo_range <- sst_range * depth_range
  
combo_range[is.na(combo_range)] <- 0

# Step 3: Convert suitable area to a stars object
combo_range <- st_as_stars(combo_range)

area_map <- tm_shape(central_california) +
  tm_polygons() + 
  tm_shape(combo_range) +
  tm_raster() +
  tm_shape(central_california) +
  tm_borders() +
  tm_layout(title = paste("Map of Depth and Temperature for", species_name))


print(area_map)

}
```

```{r}
# Use function
area_map_fun(-10, 100, -50, -20, "Pandas")
```

I would like it to color each eez area by which area has the most amount of suitable area in it. 

Because I made a variable that labeled all habitat within an area that is suitable as 1 and all that is not suitable as 0, I think I could do this by adding all the ones together, the area with the most ones would be the area with the most suitable habitat. So somehow I need to take the combo_range function, split it into the eez areas, and have it count which one has the highest value

### Finding the most amount of suitable habitat in each region

My thought process for this is that since we have already turned the suitable depth and temperatures into 1s and 0s, the was we can find the region with the most suitable habitat is by summing up the number of 1s in each region, and the region with the most 1s will have the most suitable habitat. Here is what we need to do to accomplish this.

1. figure out a way to filter the raster values to the specifc region
2. add up all the ones in that area
3. Make a heat map that shows the region with the highest value as having the most suitable habitat

```{r}
# Step 1: Rasterize the wc_regions_clean shapefile to match the suitable_locations raster
region_raster <- st_rasterize(wc_regions_clean, suitable_locations, field = "rgn", fun = "first")

# Step 2: Multiply suitable_locations raster by the region_raster
suitable_by_region <- suitable_locations * region_raster

# Step 3: Sum values within each region
region_sums <- st_extract(suitable_by_region, wc_regions_clean, fun = sum, na.rm = TRUE)

# Convert results to a data frame
region_sums_df <- data.frame(region = wc_regions_clean$rgn, suitable_area_sum = region_sums)
print(region_sums_df)
```

## Determine the most suitable EEZ
### The functionall finished function

```{r}
# Create function
area_map_fun <- function(min_temp, max_temp, min_depth, max_depth, species_name) {
  
  # Reclassify Depth (keep logical 1/0 format)
  depth_range <- (depth_clean >= min_depth & depth_clean <= max_depth)
  
  # Convert logical values (TRUE/FALSE) to integers (1/0)
  depth_range <- st_apply(depth_range, c("x", "y"), function(x) as.integer(x))
  
  depth_range[is.na(depth_range)] <- 0
  
  ## Reclassify SST (keep logical 1/0 format)
  sst_range <- (celsius_mean_sst >= min_temp & celsius_mean_sst <= max_temp)
  
  # Convert the logical values (TRUE/FALSE) to integers (1/0) and preserve the stars format
  sst_range <- st_apply(sst_range, c("x", "y"), function(x) as.integer(x))
  
  sst_range[is.na(sst_range)] <- 0
  
  combo_range <- sst_range * depth_range
  
  combo_range[is.na(combo_range)] <- 0
  
  # Convert suitable area to a stars object
  combo_range <- st_as_stars(combo_range)
  
  # Step 2: Rasterize the wc_regions_clean shapefile to match the suitable_locations raster
  region_raster <- st_rasterize(wc_regions_clean, combo_range, field = "rgn", fun = "first")
  
  # Step 3: Multiply suitable_locations raster by the region_raster
  suitable_test <- combo_range * region_raster
  
  # Step 4: Sum values within each region
  region_sums <- st_extract(suitable_test, wc_regions_clean, fun = sum, na.rm = TRUE)
  
  # Create the heat map using the correct format (stars or raster)
  area_map <- tm_shape(wc_regions_clean) +
    tm_polygons() +  # Draw the boundaries of regions
    tm_shape(region_sums) +
    tm_fill(palette = "YlGnBu", title = "Suitable Habitat Area") +  # Color by suitable habitat area
    tm_borders() +  # Add borders to the regions
    tm_layout(title = paste("Map of Depth and Temperature for", species_name))
  
  # Print the map
  print(area_map)
}
```

```{r}
# Use function
area_map_fun(0, 10, -Inf, Inf, "Pandas")
```




## Citations

#### Data

Flanders Marine Institute (VLIZ). (n.d.). *Exclusive Economic Zone (EEZ) boundaries*. Maritime Boundaries Database, version unknown. Retrieved from https://www.marineregions.org/eez.php (Accessed: November 29, 2024)

General Bathymetric Chart of the Oceans (GEBCO) Compilation Group. (2022). *GEBCO_2022 Grid* \[Data set\]. https://doi.org/10.5285/e0f0bb80-ab44-2739-e053-6c86abc0289c (Accessed: November 29, 2024)

National Oceanic and Atmospheric Administration (NOAA). (2018). *Daily Global 5km Satellite Sea Surface Temperature Anomaly (Version 3.1)*. NOAA Coral Reef Watch. Retrieved from https://coralreefwatch.noaa.gov/product/5km/index_5km_ssta.php (Accessed: November 29, 2024)
